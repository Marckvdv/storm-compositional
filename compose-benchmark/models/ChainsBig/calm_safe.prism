mdp

// DIM should be 1 greater than a multiple of 10
const int DIM = 101; 

// Weights below determine probability of going , e.g. when going north:
// BAB
// C^C
// D D

const bool WINDY = false;
const bool SAFE = true;

//const int WEIGHT_A = WINDY ? 38 : 188;
const int WEIGHT_A = WINDY ? 200 : 500;
const int WEIGHT_B = 3;
const int WEIGHT_C = 2;
const int WEIGHT_D = 1;

const int TOTAL_WEIGHT = WEIGHT_A + 2*WEIGHT_B + 2*WEIGHT_C + 2*WEIGHT_D;

const double PA = WEIGHT_A / TOTAL_WEIGHT;
const double PB = WEIGHT_B / TOTAL_WEIGHT;
const double PC = WEIGHT_C / TOTAL_WEIGHT;
const double PD = WEIGHT_D / TOTAL_WEIGHT;

module grid
    x : [-1 .. DIM];
    y : [-1 .. DIM];

    // specifies if the current state is normal, entry or exit
    norm_ent_exit : [0 .. 2]; 

    // Leave the entrance
    [] norm_ent_exit=1 -> 1:(norm_ent_exit'=0);

    // Enter the exit
    [] on_exit -> 1:(norm_ent_exit'=2);
    [] !playing & norm_ent_exit != 1 -> true;

    [north] playing -> PA:(y'=up)    + PB:(x'=left) & (y'=up)    + PB:(x'=right) & (y'=up)    + PC:(x'=left)  + PC:(x'=right) + PD:(y'=down)  & (x'=left)  + PD:(y'=down)  & (x'=right);
    [south] playing -> PA:(y'=down)  + PB:(x'=left) & (y'=down)  + PB:(x'=right) & (y'=down)  + PC:(x'=right) + PC:(x'=left)  + PD:(y'=up)    & (x'=right) + PD:(y'=up)    & (x'=left);
    [east]  playing -> PA:(x'=right) + PB:(y'=up)   & (x'=right) + PB:(y'=down)  & (x'=right) + PC:(y'=up)    + PC:(y'=down)  + PD:(x'=left)  & (y'=up)    + PD:(x'=left)  & (y'=down);
    [west]  playing -> PA:(x'=left)  + PB:(y'=up)   & (x'=left)  + PB:(y'=down)  & (x'=left)  + PC:(y'=down)  + PC:(y'=up)    + PD:(x'=right) & (y'=down)  + PD:(x'=right) & (y'=up);
endmodule

formula entrance_one = x=(DIM-1)/2&y=0;
formula entrance_two = x=0&y=(DIM-1)/2;
formula on_entrance = entrance_one | entrance_two;

formula exit_one = x=(DIM-1)/2&y=DIM-1;
formula exit_two = x=DIM-1&y=(DIM-1)/2;
formula on_exit = exit_one | exit_two;

formula on_grid = !on_exit & norm_ent_exit=0;
formula valid = x>=0 & y >= 0 & x < DIM & y < DIM;

formula playing = on_grid & valid & !in_hole & norm_ent_exit != 2 & norm_ent_exit != 1;

formula in_hole = SAFE ? 
    (mod(x,5)=2 & mod(y,5)=2) :
    (mod(x,5)=1 & mod(y,5)=1)|(mod(x,5)=3 & mod(y,5)=3)|(mod(x,5)=3 & mod(y,5)=3);

formula left = x-1;
formula right = x+1;
formula up = y+1;
formula down = y-1;

init
    //norm_ent_exit=1 & entrance_one
    //norm_ent_exit=1 & entrance_two   // entrance 2

    on_entrance & norm_ent_exit=1 // entrances 1 or 2
endinit
